<!doctype html>
<html lang="fi">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Tuomionp√§iv√§n bunkkeri 2.0 ‚Äì Keskilinnan piiritys</title>
<style>
:root{--bg:#090d18;--panel:#121a2e;--panel2:#1a2440;--line:#314675;--txt:#eaf0ff;--muted:#9cafda;--good:#62e6a1;--bad:#ff6f7f;--warn:#ffd36d;--acc:#8cb3ff}
*{box-sizing:border-box}body{margin:0;background:radial-gradient(circle at 50% 0%,#13203d,#090d18 70%);color:var(--txt);font:13px/1.4 Segoe UI,Arial,sans-serif}
button,input,select{background:#20305a;color:#fff;border:1px solid #4967a8;border-radius:6px;padding:5px 7px}
button:disabled{opacity:.45}
.top{position:sticky;top:0;z-index:8;display:grid;grid-template-columns:repeat(5,1fr);gap:6px;padding:7px;background:#0d1528f2;border-bottom:1px solid var(--line)}
.stat{background:var(--panel);border:1px solid var(--line);padding:6px;border-radius:8px}
.main{display:grid;grid-template-columns:360px 1fr 380px;gap:10px;padding:10px;max-width:1900px;margin:auto}
.panel{background:var(--panel);border:1px solid var(--line);border-radius:10px;padding:9px}
.list{max-height:78vh;overflow:auto;display:flex;flex-direction:column;gap:7px}
.card{background:var(--panel2);border:1px solid #3c548d;border-radius:9px;padding:8px}
.row{display:flex;justify-content:space-between;gap:6px;flex-wrap:wrap}.muted{color:var(--muted)}.good{color:var(--good)}.bad{color:var(--bad)}.warn{color:var(--warn)}
.tabs{display:flex;gap:5px;flex-wrap:wrap;margin-bottom:7px}.tabs button.active{outline:2px solid #7ea5ff}
canvas{width:100%;height:74vh;border:1px solid var(--line);border-radius:10px;background:radial-gradient(circle at 50% 52%,#22345f,#0f172c 62%,#0a1020)}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:6px}.tiny{font-size:12px}.mod{display:inline-block;width:12px;height:12px;margin-right:3px;border-radius:2px}
.banner{position:absolute;left:50%;top:18%;transform:translateX(-50%);background:#1c2f62de;border:1px solid #7ea5ff;padding:8px 16px;border-radius:999px;font-weight:700;opacity:0;transition:.4s}
.wrapCanvas{position:relative}.scanline{position:absolute;inset:0;pointer-events:none;background:repeating-linear-gradient(to bottom,#ffffff08 0 2px,#0000 2px 4px);mix-blend-mode:soft-light}
@media (max-width:1450px){.main{grid-template-columns:1fr}.list{max-height:none}canvas{height:55vh}}
</style>
</head>
<body>
<div class="top" id="top"></div>
<div class="main">
  <div class="panel">
    <div class="tabs" id="catTabs"></div>
    <div class="grid2 tiny" style="margin-bottom:7px">
      <input id="search" placeholder="Search building" />
      <select id="tierFilter"><option value="0">Tier All</option><option value="1">Tier 1</option><option value="2">Tier 2</option><option value="3">Tier 3</option></select>
      <select id="sortBy"><option value="cost">Sort: Cost</option><option value="output">Sort: Output</option><option value="upkeep">Sort: Upkeep</option><option value="dps">Sort: DPS</option><option value="mitigation">Sort: Mitigation</option></select>
      <button id="exportData">Export JSON</button>
    </div>
    <div class="list" id="buildingCards"></div>
  </div>

  <div class="panel">
    <div class="wrapCanvas">
      <canvas id="game" width="1050" height="700"></canvas>
      <div class="scanline"></div>
      <div class="banner" id="waveBanner"></div>
    </div>
    <div class="row tiny" style="margin-top:6px">
      <div id="combatHud"></div>
      <div>
        <button onclick="saveGame()">Save</button>
        <button onclick="loadGame()">Load</button>
        <button onclick="resetGame()">Reset</button>
      </div>
    </div>
  </div>

  <div class="panel">
    <h3 style="margin:3px 0">Live Stats</h3>
    <div id="liveStats" class="tiny"></div>
    <h3 style="margin:10px 0 4px">Module Shop</h3>
    <div class="grid2 tiny">
      <select id="moduleType"></select>
      <select id="moduleTarget"></select>
      <button id="buyModule">Buy + Install</button>
      <div id="moduleInfo" class="muted"></div>
    </div>
    <h3 style="margin:10px 0 4px">Bonus Shop</h3>
    <div id="bonusShop" class="list" style="max-height:220px"></div>
    <h3 style="margin:10px 0 4px">Fortress Visual Stats</h3>
    <div id="fortressStats" class="tiny"></div>
  </div>
</div>
<script>
const BALANCE={seed:1337,attackInterval:60,maxEnemies:120,baseCore:200,waveMul:1.12,ascendCap:25};
const MODULES={
  copperCoil:{name:'Copper Coil',color:'#ffd27a',costM:220,costMat:38,eff:{energyProduction:0.12}},
  reinforcedPlate:{name:'Reinforced Plate',color:'#92a3c8',costM:240,costMat:44,eff:{wallIntegrity:0.05,mitigation:0.03}},
  opticsLens:{name:'Optics Lens',color:'#8ae2ff',costM:260,costMat:42,eff:{towerRange:0.08}},
  highCaliber:{name:'High-Caliber Kit',color:'#ff9a7a',costM:280,costMat:50,eff:{towerDps:0.11}},
  autoLoader:{name:'Auto-Loader',color:'#ffd7f3',costM:300,costMat:58,eff:{ammoUse:-0.1}},
  coolingUnit:{name:'Cooling Unit',color:'#7affdb',costM:300,costMat:56,eff:{energyUse:-0.1}},
  hydroBooster:{name:'Hydro Booster',color:'#85ff7a',costM:230,costMat:40,eff:{foodProduction:0.12}},
  marketAlgo:{name:'Market Algorithm',color:'#b7ff7a',costM:240,costMat:42,eff:{moneyProduction:0.11}},
  salvageMagnet:{name:'Salvage Magnet',color:'#c9b2ff',costM:250,costMat:45,eff:{materialsProduction:0.12}},
  medPack:{name:'Med Pack',color:'#ff7a9f',costM:260,costMat:42,eff:{repair:0.13,regen:0.1}}
};
const BONUS={money:{name:'Money +10%',step:.1,cap:2.5},food:{name:'Food +10%',step:.1,cap:2.5},energy:{name:'Energy +8%',step:.08,cap:1.8},defense:{name:'Defense +8%',step:.08,cap:1.8},upkeep:{name:'Upkeep -7%',step:-.07,cap:-.6},rewards:{name:'Rewards +8%',step:.08,cap:1.6}};
const state={money:5000,food:1500,materials:800,energy:200,ammo:300,foodCap:1200,materialsCap:1200,energyCap:600,ammoCap:800,
baseHP:200,wave:1,nextWave:BALANCE.attackInterval,time:0,enemies:[],particles:[],floaters:[],bullets:[],squadsRemaining:0,threat:0,
outer:100,inner:100,coreHP:200,status:{starving:false,blackout:false,lowAmmo:false},globalEfficiency:1,targetMode:'nearest',
coreLevel:1,wallLevel:1,towerLevel:1,gateLevel:1,cannonPlatforms:0,trapsLevel:1,ascendRank:0,shake:0,zoom:1,
buildings:[],buildingState:{},tab:'economy',modulesOwned:{},modulesByBuilding:{},bonusLevels:{},activeCracks:Array(8).fill(0),waveInfo:{}};

function rng(seed){let x=seed>>>0;return()=>((x=(1664525*x+1013904223)>>>0)/4294967296)}
function pick(r,arr){return arr[Math.floor(r()*arr.length)]}
function tierByRoll(v){return v<.6?1:v<.9?2:3}
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function logSoft(level){return (1+0.2*(level-1))*(1+0.95*Math.log10(1+level))}

function generateBuildings(seed){
  const r=rng(seed),list=[],used=new Set();
  const prefix=['Iron','Ash','Doom','Vault','Crimson','Obsidian','Last','Silent','Warden','Grim','Nova','Ruin','Steel','Night','Hollow','End'];
  const suffix=['Mk.I','Mk.II','Mk.III','Protocol','Division','Circuit','Line','Wing','Annex','Sector','Module','Station','Works','Guild','Engine','Grid','Chain','Core','Vault','Stack'];
  const defs={
    economy:['Market','Exchange','Banking','Trade Hub','Depot','Mint','Ledger','Courier'],
    defense:['Tower','Bastion','Array','Gate','Bulwark','Platform','Battery','Rampart'],
    utility:['Reactor','Silo','Lab','Node','Foundry','Ward','Relay','Press']
  };
  const archetypes={
    economy:[['Cashflow',{money:[4,16],tags:['producer','economy'],pri:'money/s',sec:'reward%'}],['Trade',{money:[6,20],tags:['economy','support'],pri:'money/s',sec:'reward%'}],['Interest',{money:[5,14],tags:['economy'],pri:'money/s',sec:'moneyCap+'}],['Efficiency',{money:[3,10],tags:['economy'],pri:'buildCost-',sec:'money/s'}],['RewardBoost',{money:[4,12],tags:['economy'],pri:'reward%',sec:'money/s'}],['RiskyProfit',{money:[8,24],tags:['economy','consumer'],pri:'money/s',sec:'upkeep+'}],['TaxOffice',{money:[5,15],tags:['economy'],pri:'upkeep-',sec:'mitigation%'}],['CourierNet',{money:[4,13],tags:['economy','support'],pri:'money/s',sec:'early warning'}]],
    defense:[['SingleTarget',{dps:[5,18],range:[150,220],tags:['defense','siege'],pri:'DPS',sec:'range'}],['RapidFire',{dps:[8,20],range:[130,190],ammo:[.4,1.2],tags:['defense','consumer'],pri:'DPS',sec:'ammoUse'}],['AoE',{dps:[10,22],aoe:[20,55],ammo:[.8,1.8],tags:['defense','siege'],pri:'AoE DPS',sec:'aoe'}],['SlowAura',{dps:[4,11],slow:[.06,.18],tags:['defense','support'],pri:'slow%',sec:'DPS'}],['BurnDoT',{dps:[5,14],burn:[.05,.15],tags:['defense','siege'],pri:'burn%',sec:'DPS'}],['StunEMP',{dps:[3,10],stun:[.02,.08],tags:['defense','support'],pri:'stun%',sec:'DPS'}],['Mitigation',{mit:[.01,.06],tags:['defense','fortress'],pri:'mitigation%',sec:'wall'}],['Shield',{shield:[1,10],tags:['defense','fortress'],pri:'shieldFlat',sec:'energyUse'}]],
    utility:[['FoodProd',{food:[4,18],tags:['utility','producer'],pri:'food/s',sec:'morale'}],['MaterialsProd',{mat:[1.5,6],energyUse:[.3,1.3],tags:['utility','consumer'],pri:'materials/s',sec:'money/s'}],['EnergyProd',{energy:[1.5,8],foodUse:[.2,1.2],tags:['utility','producer'],pri:'energy/s',sec:'energyCap+'}],['AmmoProd',{ammo:[.8,3.5],matUse:[.2,1.1],energyUse:[.2,1],tags:['utility','consumer'],pri:'ammo/s',sec:'materials use'}],['Storage',{caps:[30,120],tags:['utility','support'],pri:'cap+',sec:'money/s'}],['Repair',{repair:[.5,2],tags:['utility','fortress'],pri:'repair%',sec:'regen'}],['Intel',{crit:[.01,.07],tags:['utility','support'],pri:'critBonus',sec:'accuracy'}],['Morale',{morale:[.01,.06],tags:['utility'],pri:'globalEff%',sec:'food/s'}]]
  };
  const tierScale={1:{c:[200,900],o:1,u:1,t:1},2:{c:[700,2200],o:1.35,u:1.22,t:1.18},3:{c:[1800,6500],o:1.85,u:1.55,t:1.40}};

  for(const cat of ['economy','defense','utility']){
    archetypes[cat].forEach(([arch,templ],idx)=>{
      for(let v=0;v<5;v++){
        const t=tierByRoll(r()),ts=tierScale[t],core=pick(r,defs[cat]);
        let name=`${pick(r,prefix)} ${core} ${pick(r,suffix)}`;let dupe=2;while(used.has(name)){name+=`-${dupe++}`}used.add(name);
        const varOut=1+(r()*0.24-0.12),varUp=1+(r()*0.2-0.1),varR=1+(r()*0.16-0.08);
        const money=(templ.money?((templ.money[0]+r()*(templ.money[1]-templ.money[0]))*ts.o*varOut):0);
        const food=(templ.food?((templ.food[0]+r()*(templ.food[1]-templ.food[0]))*ts.o*varOut):0);
        const materials=(templ.mat?((templ.mat[0]+r()*(templ.mat[1]-templ.mat[0]))*ts.o*varOut):0);
        const energy=(templ.energy?((templ.energy[0]+r()*(templ.energy[1]-templ.energy[0]))*ts.o*varOut):0);
        const ammo=(templ.ammo?((templ.ammo[0]+r()*(templ.ammo[1]-templ.ammo[0]))*ts.o*varOut):0);
        const dps=(templ.dps?((templ.dps[0]+r()*(templ.dps[1]-templ.dps[0]))*ts.o*varOut):0);
        const range=(templ.range?(templ.range[0]+r()*(templ.range[1]-templ.range[0]))*varR:130+70*r());
        const aoe=(templ.aoe?(templ.aoe[0]+r()*(templ.aoe[1]-templ.aoe[0]))*varR:0);
        const slow=templ.slow?templ.slow[0]+r()*(templ.slow[1]-templ.slow[0]):0;
        const burn=templ.burn?templ.burn[0]+r()*(templ.burn[1]-templ.burn[0]):0;
        const stun=templ.stun?templ.stun[0]+r()*(templ.stun[1]-templ.stun[0]):0;
        const mit=templ.mit?templ.mit[0]+r()*(templ.mit[1]-templ.mit[0]):0;
        const shield=templ.shield?templ.shield[0]+r()*(templ.shield[1]-templ.shield[0]):0;
        const upkeepF=((templ.foodUse?templ.foodUse[0]+r()*(templ.foodUse[1]-templ.foodUse[0]):0.2+r()*1.4*(cat==='defense'?0.6:1))*ts.u*varUp);
        const upkeepE=((templ.energyUse?templ.energyUse[0]+r()*(templ.energyUse[1]-templ.energyUse[0]):(t>1?(0.2+r()*1.8):0))*ts.u*varUp);
        const ammoUse=((templ.ammo?0.15*templ.ammo[0]+r()*0.4:0)*ts.u*varUp);
        const costMoney=Math.round((ts.c[0]+r()*(ts.c[1]-ts.c[0]))*(1+idx*0.02));
        const costMat=t===1?0:Math.round((200+r()*1000)*(t===3?1:0.45));
        list.push({id:`${cat}_${idx}_${v}`,name,category:cat,tier:t,tags:[...new Set([...templ.tags,cat,'support'])],iconGlyph:cat==='economy'?'üí∞':cat==='defense'?'üõ°':'‚öô',description:`${arch} pattern`,
          baseCostMoney:costMoney,baseCostMaterials:costMat,costGrowth:1.115+r()*0.035,
          baseUpgradeCostMoney:Math.round(costMoney*0.82),baseUpgradeCostMaterials:Math.round(costMat*0.55),
          baseUpkeepFood:Math.max(0,upkeepF),baseUpkeepEnergy:Math.max(0,upkeepE),baseAmmoUse:Math.max(0,ammoUse),
          outputs:{moneyPer:money,foodPer:food,materialsPer:materials,energyPer:energy,ammoPer:ammo},
          combat:{towerDps:dps,range,aoeRadius:aoe,slowChance:slow,burnChance:burn,stunChance:stun,critBonus:templ.crit?templ.crit[0]+r()*(templ.crit[1]-templ.crit[0]):0,shieldFlat:shield,mitigation:mit},
          slots:t===1?(3+Math.floor(r()*2)):t===2?(4+Math.floor(r()*2)):(5+Math.floor(r()*2)),
          primaryAttr:templ.pri,secondaryAttr:templ.sec,
          visualImpact:{coreGrow:cat==='utility'?1+r()*2:0.2+r(),wallThicken:cat==='defense'?1+r()*2:0.2+r()*0.5,addTowerChance:cat==='defense'?1+r()*3:r()*0.6,addPlatformChance:cat==='defense'?r()*2:cat==='utility'?r():0,
            wallCrackResist:cat==='defense'?0.3+r()*1.2:0.1+r()*0.3,glowPower:cat==='economy'?0.5+r()*1.2:0.2+r()*0.8}
        })
      }
    })
  }
  return list;
}

function init(){
  state.buildings=generateBuildings(BALANCE.seed);
  state.buildings.forEach(b=>state.buildingState[b.id]={count:0,level:1,modules:[]});
  ['economy','defense','utility','fortress'].forEach(t=>{const b=document.createElement('button');b.textContent=t;b.onclick=()=>{state.tab=t;updateUI()};catTabs.appendChild(b)});
  Object.entries(MODULES).forEach(([k,v])=>moduleType.add(new Option(v.name,k)));
  Object.entries(BONUS).forEach(([k,v])=>state.bonusLevels[k]=0);
  buyModule.onclick=buyAndInstallModule; exportData.onclick=()=>navigator.clipboard?.writeText(JSON.stringify(state.buildings,null,2));
  ['search','tierFilter','sortBy'].forEach(id=>document.getElementById(id).oninput=updateUI);
  startWave();requestAnimationFrame(loop);updateUI();
}

function getTierMult(t){return [1,1,1.18,1.4][t]}
function nextBuildCost(b,qty=1){const s=state.buildingState[b.id];let m=0,mat=0;for(let i=0;i<qty;i++){const c=s.count+i;m+=b.baseCostMoney*(b.costGrowth**c)*(1+0.05*(s.level-1))*getTierMult(b.tier);mat+=b.baseCostMaterials*(b.costGrowth**c)*0.25;}return{money:m,materials:mat}}
function nextUpgradeCost(b,qty=1){const s=state.buildingState[b.id];let m=0,mat=0;for(let i=0;i<qty;i++){const lv=s.level+i;m+=b.baseUpgradeCostMoney*(1.82**(lv-1))*(1.12**s.count)*getTierMult(b.tier);mat+=b.tier>1?b.baseUpgradeCostMaterials*(1.55**(lv-1)):0;}return{money:m,materials:mat}}
function installModuleCost(type){const n=state.modulesOwned[type]||0;const m=MODULES[type];return{money:m.costM*(1+0.18*n),materials:m.costMat*(1+0.14*n)}}

function buyBuilding(id,n=1){const b=state.buildings.find(x=>x.id===id);const c=nextBuildCost(b,n);if(state.money>=c.money&&state.materials>=c.materials){state.money-=c.money;state.materials-=c.materials;state.buildingState[id].count+=n;updateUI()}}
function upgBuilding(id,n=1){const b=state.buildings.find(x=>x.id===id);const c=nextUpgradeCost(b,n);if(state.money>=c.money&&state.materials>=c.materials){state.money-=c.money;state.materials-=c.materials;state.buildingState[id].level+=n;if(state.buildingState[id].level>=30&&state.ascendRank<BALANCE.ascendCap)state.ascendRank++;state.zoom=1.04;updateUI()}}
function upgradeFortress(type,n){const c=(200+state[type]*70)*n;if(state.money<c||state.materials<c*0.32)return;state.money-=c;state.materials-=c*0.32;state[type]+=n;if(type==='cannonPlatforms')state[type]=Math.min(16,state[type]);if(type==='towerLevel'||type==='coreLevel'||type==='wallLevel')state.zoom=1.06}

function moduleMulForBuilding(bs){const eff={};bs.modules.forEach(m=>Object.entries(MODULES[m].eff).forEach(([k,v])=>eff[k]=(eff[k]||0)+v));return eff}
function totalVisual(){
  const v={coreGrow:0,wallThicken:0,addTowerChance:0,addPlatformChance:0,wallCrackResist:0,glowPower:0};
  state.buildings.forEach(b=>{const s=state.buildingState[b.id],lvl=logSoft(s.level);Object.keys(v).forEach(k=>v[k]+=b.visualImpact[k]*s.count*lvl)});
  v.coreRadius=70+state.coreLevel*1.5+v.coreGrow*0.15;v.wallThickness=8+state.wallLevel*0.6+v.wallThicken*0.10;
  v.towerVisibleCount=Math.floor(clamp(4+state.towerLevel/3+v.addTowerChance*0.25,4,28));
  v.platformCount=Math.floor(clamp(state.cannonPlatforms+v.addPlatformChance*0.15,0,18));
  v.crackResist=clamp(v.wallCrackResist*0.02,0,0.35);v.glow=clamp(v.glowPower*0.02,0,1);
  return v;
}

function computeRates(){
  let r={money:0,food:0,materials:0,energy:0,ammo:0,foodUse:0,energyUse:0,ammoUse:0,dps:0,mit:0,shield:0,range:180,slow:0,burn:0,stun:0,crit:0,repair:0,regen:0,moneyCap:0};
  const moneyTop=[],energyTop=[],defBreak=[];
  state.buildings.forEach(b=>{const s=state.buildingState[b.id];if(!s.count)return;const lv=logSoft(s.level),mods=moduleMulForBuilding(s),a=1+0.08*state.ascendRank;
    const prodMul=1+(mods.moneyProduction||0)+(mods.foodProduction||0)+(mods.energyProduction||0)+(mods.materialsProduction||0);
    const out={money:b.outputs.moneyPer*s.count*lv*a,food:b.outputs.foodPer*s.count*lv*a,materials:b.outputs.materialsPer*s.count*lv*a,energy:b.outputs.energyPer*s.count*lv*a,ammo:b.outputs.ammoPer*s.count*lv*a};
    r.money+=out.money*(1+(state.bonusLevels.money||0));r.food+=out.food*(1+(state.bonusLevels.food||0));r.materials+=out.materials;r.energy+=out.energy*(1+(state.bonusLevels.energy||0));r.ammo+=out.ammo;
    r.foodUse+=b.baseUpkeepFood*s.count*(1+0.1*(s.level-1))*(1+0.22*Math.log10(1+s.level))*Math.max(0.35,1+(mods.upkeep||0)+(state.bonusLevels.upkeep||0));
    r.energyUse+=b.baseUpkeepEnergy*s.count*(1+0.1*(s.level-1))*Math.max(0.35,1+(mods.energyUse||0));
    r.ammoUse+=b.baseAmmoUse*s.count*(1+0.06*(s.level-1))*Math.max(0.25,1+(mods.ammoUse||0));
    r.dps+=b.combat.towerDps*s.count*lv*(1+(mods.towerDps||0));r.range=Math.max(r.range,b.combat.range*(1+(mods.towerRange||0)));r.slow+=b.combat.slowChance*s.count*0.1;r.burn+=b.combat.burnChance*s.count*0.1;r.stun+=b.combat.stunChance*s.count*0.1;
    r.crit+=b.combat.critBonus*s.count*0.07;r.mit+=b.combat.mitigation*s.count*(1+(mods.mitigation||0));r.shield+=b.combat.shieldFlat*s.count;r.repair+=(mods.repair||0)*s.count;r.regen+=(mods.regen||0)*s.count;r.moneyCap+=b.primaryAttr==='moneyCap+'?8*s.count:0;
    if(out.money>0)moneyTop.push({n:b.name,v:out.money}); if(b.baseUpkeepEnergy*s.count>0)energyTop.push({n:b.name,v:b.baseUpkeepEnergy*s.count}); if(b.combat.towerDps>0)defBreak.push({n:b.name,v:b.combat.towerDps*s.count*lv});
  });
  state.status.starving=state.food<0;state.status.blackout=state.energy<0;state.status.lowAmmo=state.ammo<=0;
  state.globalEfficiency=(state.status.starving?0.65:1)*(state.status.blackout?0.85:1);
  const defenseMult=(state.status.starving?0.65:1)*(1+state.bonusLevels.defense||0);
  r.dps*=defenseMult*(state.status.lowAmmo?0.75:1);r.mit=clamp(r.mit*(state.outer/100*0.6+0.4),0,0.75);r.moneyTop=moneyTop.sort((a,b)=>b.v-a.v).slice(0,5);r.energyTop=energyTop.sort((a,b)=>b.v-a.v).slice(0,5);r.defBreak=defBreak.sort((a,b)=>b.v-a.v).slice(0,5);
  return r;
}

function enemySpec(type,w){const m={Grunt:[36,1.0,4],Runner:[24,1.45,3],Brute:[92,0.65,8],Shieldbearer:[58,0.95,5],Bomber:[46,1.08,6],Sniper:[38,0.9,7],Overlord:[640,0.45,22]};
  const [hp,spd,pow]=m[type];return{hp:hp*(1+w*0.1),speed:spd*(1+w*0.015),power:pow*(1+w*0.08)} }
function spawnEnemy(dir,type,tokens=1){
  const c=document.getElementById('game'),cx=c.width/2,cy=c.height/2,edge=360;const ang=dir*Math.PI/4+(Math.random()-.5)*0.35;
  const x=cx+Math.cos(ang)*edge,y=cy+Math.sin(ang)*edge,s=enemySpec(type,state.wave);state.enemies.push({x,y,type,hp:s.hp*tokens,maxHp:s.hp*tokens,speed:s.speed,power:s.power*tokens,tokens,dir:ang,atkCd:0});
}
function spawnSquads(){
  const squads=state.wave<=10?3:state.wave<=25?4:5;const per=state.wave<=10?[6,10]:state.wave<=25?[10,16]:[14,22];state.squadsRemaining=squads;
  for(let s=0;s<squads;s++){const dir=Math.floor(Math.random()*8),cnt=Math.floor(per[0]+Math.random()*(per[1]-per[0]+1));for(let i=0;i<cnt;i++){const types=['Grunt','Runner','Brute','Shieldbearer','Bomber','Sniper'];spawnEnemy(dir,types[Math.floor(Math.random()*types.length)],1)}}
  if(state.wave%10===0){spawnEnemy(Math.floor(Math.random()*8),'Overlord',1);for(let i=0;i<10;i++)spawnEnemy(Math.floor(Math.random()*8),'Grunt',1)}
  if(state.enemies.length>BALANCE.maxEnemies){const extra=state.enemies.splice(BALANCE.maxEnemies);extra.forEach(e=>spawnEnemy(Math.floor(Math.random()*8),e.type,3));}
}
function startWave(){state.waveBanner=document.getElementById('waveBanner');state.waveBanner.textContent=`AALTO ${state.wave}`;state.waveBanner.style.opacity=1;setTimeout(()=>state.waveBanner.style.opacity=0,1300);spawnSquads();}
function applyEvent(){if(Math.random()<0.3){const v=Math.random();if(v<.33)state.money+=120;else if(v<.66)state.materials+=60;else state.energy+=40;}}

function applyDamage(target,val,sector){if(target==='outer'){state.outer=Math.max(0,state.outer-val);state.activeCracks[sector]=Math.min(1,state.activeCracks[sector]+0.25)}
 else if(target==='inner')state.inner=Math.max(0,state.inner-val); else state.coreHP=Math.max(0,state.coreHP-val)}

function tick(dt){
  const r=computeRates(),v=totalVisual();
  state.food+= (r.food-r.foodUse)*dt*state.globalEfficiency; state.energy+=(r.energy-r.energyUse)*dt*state.globalEfficiency;state.ammo+=(r.ammo-r.ammoUse)*dt*state.globalEfficiency;state.money+=(r.money)*dt*state.globalEfficiency;state.materials+=(r.materials)*dt*state.globalEfficiency;
  state.food=clamp(state.food,-5000,state.foodCap);state.energy=clamp(state.energy,-5000,state.energyCap);state.ammo=clamp(state.ammo,0,state.ammoCap);state.materials=clamp(state.materials,0,state.materialsCap);state.money=Math.max(0,state.money);
  state.nextWave-=dt;if(state.nextWave<=0){state.wave++;state.nextWave=BALANCE.attackInterval;startWave();applyEvent();}
  const cx=game.width/2,cy=game.height/2,ring=130+v.wallThickness;
  state.enemies.forEach((e,idx)=>{const dx=cx-e.x,dy=cy-e.y,d=Math.hypot(dx,dy);if(d>ring){e.x+=dx/d*e.speed*dt*60*(Math.random()<0.02&&state.shake>0?0.8:1);e.y+=dy/d*e.speed*dt*60}
    else{e.atkCd-=dt;if(e.atkCd<=0){e.atkCd=0.75;const sec=Math.floor((((Math.atan2(dy,dx)+Math.PI)/(2*Math.PI))*8))%8;let dmg=e.power*0.8*(1-r.mit+0.05);if(e.type==='Bomber')dmg*=1.8,state.shake=8; if(state.outer>0)applyDamage('outer',dmg,sec);else if(state.inner>0)applyDamage('inner',dmg*0.8,sec);else applyDamage('core',dmg*0.7,sec);}}
    if(e.hp<=0)state.enemies.splice(idx,1);
  });
  const shootCount=Math.min(v.towerVisibleCount,10);for(let i=0;i<shootCount;i++){
    const target=state.enemies.reduce((a,b)=>!a||Math.hypot(b.x-cx,b.y-cy)<Math.hypot(a.x-cx,a.y-cy)?b:a,null);if(target&&state.ammo>0){const d=r.dps*dt/(shootCount||1);target.hp-=d*(1+Math.random()*r.crit);state.ammo=Math.max(0,state.ammo-r.ammoUse*dt*0.2);state.bullets.push({x:cx,y:cy,tx:target.x,ty:target.y,t:0,gl:v.glow});if(target.hp<=0){state.money+=8*target.tokens;state.materials+=2*target.tokens;for(let p=0;p<6;p++)state.particles.push({x:target.x,y:target.y,vx:(Math.random()-.5)*2,vy:(Math.random()-.5)*2,life:.5,col:'#b9c8ff'});state.floaters.push({x:target.x,y:target.y,text:`-${Math.round(d)}`,life:1})}}
  }
  state.outer=Math.min(100,state.outer+(0.2+r.repair)*dt);state.inner=Math.min(100,state.inner+(0.16+r.repair*0.7)*dt);state.coreHP=Math.min(state.baseHP,state.coreHP+(0.1+r.regen)*dt);
  state.particles=state.particles.filter(p=>(p.life-=dt)>0);state.particles.forEach(p=>{p.x+=p.vx*45*dt;p.y+=p.vy*45*dt});
  state.floaters=state.floaters.filter(f=>(f.life-=dt)>0);state.floaters.forEach(f=>f.y-=25*dt);
  state.bullets=state.bullets.filter(b=>(b.t+=dt*4)<1);state.shake=Math.max(0,state.shake-dt*12);state.zoom+= (1-state.zoom)*Math.min(1,dt*5);
  state.activeCracks=state.activeCracks.map(v=>Math.max(0,v-dt*0.07));
  if(state.coreHP<=0)resetGame();
}

function draw(){const c=game,ctx=c.getContext('2d'),v=totalVisual(),cx=c.width/2,cy=c.height/2;ctx.clearRect(0,0,c.width,c.height);
  const sx=(Math.random()-.5)*state.shake,sy=(Math.random()-.5)*state.shake;ctx.save();ctx.translate(cx+sx,cy+sy);ctx.scale(state.zoom,state.zoom);ctx.translate(-cx,-cy);
  for(let i=0;i<30;i++){ctx.fillStyle=`rgba(120,170,255,${0.04+v.glow*0.03})`;ctx.fillRect(i*36%1050,(i*83)%700,2,2)}
  const rCore=v.coreRadius,outerR=130+v.wallThickness,innerR=108+v.wallThickness*0.6;
  ctx.strokeStyle='#95b6ff';ctx.lineWidth=2+v.glow*3;ctx.shadowColor='#85b3ff';ctx.shadowBlur=12*v.glow;ctx.beginPath();ctx.arc(cx,cy,rCore,0,Math.PI*2);ctx.stroke();ctx.shadowBlur=0;
  for(let k=0;k<Math.floor(state.coreLevel/2)+1;k++){ctx.strokeStyle=`rgba(170,200,255,${0.15-k*0.02})`;ctx.beginPath();ctx.arc(cx,cy,rCore+8+k*6,0,Math.PI*2);ctx.stroke()}
  ctx.lineWidth=v.wallThickness;ctx.strokeStyle='#b8c5de';ctx.beginPath();ctx.arc(cx,cy,outerR,0,Math.PI*2);ctx.stroke();
  ctx.lineWidth=6+state.wallLevel*0.2;ctx.strokeStyle='#7f91b8';ctx.beginPath();ctx.arc(cx,cy,innerR,0,Math.PI*2);ctx.stroke();
  for(let s=0;s<8;s++){if(state.activeCracks[s]>0){ctx.strokeStyle=`rgba(255,120,120,${state.activeCracks[s]*0.7})`;ctx.lineWidth=3;ctx.beginPath();const a=s*Math.PI/4;ctx.moveTo(cx+Math.cos(a)*outerR,cy+Math.sin(a)*outerR);ctx.lineTo(cx+Math.cos(a)*(outerR+20),cy+Math.sin(a)*(outerR+20));ctx.stroke();}}
  for(let i=0;i<v.towerVisibleCount;i++){const a=i*(Math.PI*2/v.towerVisibleCount),rr=outerR+14;ctx.fillStyle='#d8e5ff';ctx.beginPath();ctx.arc(cx+Math.cos(a)*rr,cy+Math.sin(a)*rr,5,0,6.28);ctx.fill();ctx.strokeStyle='#7bc4ff';ctx.beginPath();ctx.moveTo(cx+Math.cos(a)*rr,cy+Math.sin(a)*rr);ctx.lineTo(cx+Math.cos(a)*(rr+8),cy+Math.sin(a)*(rr+8));ctx.stroke();}
  for(let i=0;i<v.platformCount;i++){const a=i*(Math.PI*2/Math.max(1,v.platformCount)),rr=innerR-16;ctx.fillStyle='#ffbc79';ctx.fillRect(cx+Math.cos(a)*rr-5,cy+Math.sin(a)*rr-5,10,10)}
  state.bullets.forEach(b=>{ctx.strokeStyle=`rgba(160,220,255,${1-b.t})`;ctx.lineWidth=2+2*b.gl;ctx.beginPath();ctx.moveTo(b.x,b.y);ctx.lineTo(b.tx,b.ty);ctx.stroke()});
  state.enemies.forEach(e=>{const sc=e.type==='Brute'?1.35:e.type==='Runner'?0.8:e.type==='Overlord'?1.8:1;ctx.strokeStyle=e.type==='Shieldbearer'?'#89d4ff':e.type==='Bomber'?'#ffaf6b':'#fff';ctx.lineWidth=2;
    ctx.beginPath();ctx.arc(e.x,e.y-6*sc,4*sc,0,6.28);ctx.stroke();ctx.beginPath();ctx.moveTo(e.x,e.y-2*sc);ctx.lineTo(e.x,e.y+8*sc);ctx.moveTo(e.x,e.y+8*sc);ctx.lineTo(e.x-4*sc,e.y+14*sc);ctx.moveTo(e.x,e.y+8*sc);ctx.lineTo(e.x+4*sc,e.y+14*sc);ctx.moveTo(e.x,e.y+2*sc);ctx.lineTo(e.x+6*sc,e.y+3*sc);ctx.stroke();if(e.tokens>1){ctx.fillStyle='#ffd';ctx.fillText('x'+e.tokens,e.x+6,e.y-10)}});
  state.particles.forEach(p=>{ctx.fillStyle=p.col;ctx.fillRect(p.x,p.y,2,2)});state.floaters.forEach(f=>{ctx.fillStyle='#ffb9b9';ctx.fillText(f.text,f.x,f.y)});
  ctx.restore();
}

function fmt(v){return (Math.round(v*10)/10).toLocaleString('fi-FI')}
function tt(cur,net,cap){if(net>0)return `${fmt((cap-cur)/net)}s full`; if(net<0)return `${fmt(cur/Math.abs(net))}s empty`; return '‚Äî'}
function updateUI(){
  const r=computeRates(),v=totalVisual();
  top.innerHTML=`<div class=stat>Money ${fmt(state.money)} /s <span class='good'>${fmt(r.money)}</span></div>
    <div class=stat>Food ${fmt(state.food)}/${state.foodCap} net ${fmt(r.food-r.foodUse)}</div>
    <div class=stat>Materials ${fmt(state.materials)}/${state.materialsCap} net ${fmt(r.materials)}</div>
    <div class=stat>Energy ${fmt(state.energy)}/${state.energyCap} net ${fmt(r.energy-r.energyUse)}</div>
    <div class=stat>Ammo ${fmt(state.ammo)}/${state.ammoCap} net ${fmt(r.ammo-r.ammoUse)} | Wave ${state.wave} in ${fmt(state.nextWave)}s</div>`;
  combatHud.innerHTML=`Enemies ${state.enemies.length} | Squads ${state.squadsRemaining} | Threat ${fmt(state.threat)}<br>Outer ${fmt(state.outer)}% | Inner ${fmt(state.inner)}% | Core ${fmt(state.coreHP)}/${state.baseHP}<br>Ammo use/s ${fmt(r.ammoUse)} | Energy use/s ${fmt(r.energyUse)} | mode ${state.targetMode}`;
  fortressStats.innerHTML=`CoreLevel ${state.coreLevel} | WallLevel ${state.wallLevel} | TowerLevel ${state.towerLevel} | GateLevel ${state.gateLevel}<br>
  CannonPlatforms ${state.cannonPlatforms} | Traps ${state.trapsLevel} | Ascend ${state.ascendRank}<br>
  coreRadius ${fmt(v.coreRadius)} | wallThickness ${fmt(v.wallThickness)} | towers ${v.towerVisibleCount} | platforms ${v.platformCount} | crackResist ${fmt(v.crackResist*100)}%`+
  `<div class='row' style='margin-top:4px'><button onclick="upgradeFortress('coreLevel',1)">Core +1</button><button onclick="upgradeFortress('coreLevel',10)">Core +10</button><button onclick="upgradeFortress('wallLevel',1)">Wall +1</button><button onclick="upgradeFortress('wallLevel',10)">Wall +10</button><button onclick="upgradeFortress('towerLevel',1)">Tower +1</button><button onclick="upgradeFortress('towerLevel',10)">Tower +10</button><button onclick="upgradeFortress('cannonPlatforms',1)">Platform +1</button></div>`;

  const live=`Energy: prod/s ${fmt(r.energy)} cons/s ${fmt(r.energyUse)} net ${fmt(r.energy-r.energyUse)} now ${fmt(state.energy)}/${state.energyCap} ${tt(state.energy,r.energy-r.energyUse,state.energyCap)}<br>
  Ammo: prod/s ${fmt(r.ammo)} cons/s ${fmt(r.ammoUse)} net ${fmt(r.ammo-r.ammoUse)}<br>
  Money: prod/s ${fmt(r.money)} net/s ${fmt(r.money)}<br>
  Food: prod/s ${fmt(r.food)} upkeep/s ${fmt(r.foodUse)} net/s ${fmt(r.food-r.foodUse)}<br>
  Materials: prod/s ${fmt(r.materials)} net/s ${fmt(r.materials)}<br>
  <hr>Top 5 money producers:<br>${r.moneyTop.map(x=>`${x.n}: ${fmt(x.v)}`).join('<br>')||'-'}<br><hr>
  Top 5 energy consumers:<br>${r.energyTop.map(x=>`${x.n}: ${fmt(x.v)}`).join('<br>')||'-'}<br><hr>
  Defense breakdown:<br>${r.defBreak.map(x=>`${x.n}: ${fmt(x.v)} DPS`).join('<br>')||'-'}<br>
  multipliers: eff ${fmt(state.globalEfficiency)} starving ${state.status.starving?'ON':'off'} blackout ${state.status.blackout?'ON':'off'} lowAmmo ${state.status.lowAmmo?'ON':'off'}`;
  liveStats.innerHTML=live;

  bonusShop.innerHTML='';Object.entries(BONUS).forEach(([k,b])=>{const lv=state.bonusLevels[k],val=lv*b.step;const card=document.createElement('div');card.className='card tiny';const price=300*(1+lv*1.65);
    card.innerHTML=`<b>${b.name}</b> <div>${fmt(val*100)}% / cap ${fmt(b.cap*100)}%</div><button>${fmt(price)} money</button>`;card.querySelector('button').onclick=()=>{if(Math.abs(val+b.step)<=Math.abs(b.cap)&&state.money>=price){state.money-=price;state.bonusLevels[k]++}};bonusShop.appendChild(card)});

  moduleTarget.innerHTML='';state.buildings.filter(b=>state.buildingState[b.id].count>0).forEach(b=>moduleTarget.add(new Option(b.name,b.id)));
  const mc=installModuleCost(moduleType.value||Object.keys(MODULES)[0]);moduleInfo.textContent=`${fmt(mc.money)} money + ${fmt(mc.materials)} materials`;

  document.querySelectorAll('#catTabs button').forEach(b=>b.classList.toggle('active',b.textContent===state.tab));
  const term=search.value.toLowerCase(),tier=+tierFilter.value,sort=sortBy.value;
  let list=state.buildings.filter(b=>(state.tab==='fortress'?false:b.category===state.tab)&&(!tier||b.tier===tier)&&b.name.toLowerCase().includes(term));
  list.sort((a,b)=>{const sa=state.buildingState[a.id],sb=state.buildingState[b.id];
    if(sort==='cost')return nextBuildCost(a,1).money-nextBuildCost(b,1).money;
    if(sort==='output')return (b.outputs.moneyPer+b.outputs.foodPer+b.outputs.materialsPer+b.outputs.energyPer+b.outputs.ammoPer)-(a.outputs.moneyPer+a.outputs.foodPer+a.outputs.materialsPer+a.outputs.energyPer+a.outputs.ammoPer);
    if(sort==='upkeep')return (b.baseUpkeepEnergy+b.baseUpkeepFood)-(a.baseUpkeepEnergy+a.baseUpkeepFood);
    if(sort==='dps')return b.combat.towerDps-a.combat.towerDps;return b.combat.mitigation-a.combat.mitigation;
  });
  buildingCards.innerHTML='';list.forEach(b=>{const s=state.buildingState[b.id],mods=moduleMulForBuilding(s),cost=nextBuildCost(b,1),up=nextUpgradeCost(b,1),mm=s.modules.map(m=>`<span class='mod' style='background:${MODULES[m].color}' title='${MODULES[m].name}'></span>`).join('');
    const baseVal=(b.outputs.moneyPer||b.outputs.foodPer||b.outputs.energyPer||b.outputs.materialsPer||b.outputs.ammoPer||b.combat.towerDps||b.combat.mitigation*100||0);const modVal=(mods.towerDps||mods.moneyProduction||mods.foodProduction||mods.energyProduction||mods.materialsProduction||mods.mitigation||0);
    const tot=baseVal*logSoft(s.level)*s.count*(1+modVal);
    const el=document.createElement('div');el.className='card tiny';el.innerHTML=`<div class='row'><b>${b.iconGlyph} ${b.name}</b><span>T${b.tier}</span></div>
      <div class='muted'>${b.description} ‚Ä¢ slots ${b.slots}</div>
      <div>Base effect: cnt ${s.count}, lvl ${s.level}</div>
      <div>Module bonus: +${fmt(modVal*100)}%</div>
      <div>Total effective: ${fmt(tot)}</div>
      <div>Adds +${fmt(baseVal)} to ${b.primaryAttr} | +${b.secondaryAttr}</div>
      <div>${mm||'<span class=muted>No modules</span>'}</div>
      <div class='row'><button class=b1>Build</button><button class=b5>x5</button><button class=u1>Upg+1</button><button class=u10>Upg+10</button></div>
      <div class='muted'>Cost ${fmt(cost.money)}M ${fmt(cost.materials)}Mat | Upg ${fmt(up.money)}M ${fmt(up.materials)}Mat</div>`;
    el.querySelector('.b1').onclick=()=>buyBuilding(b.id,1);el.querySelector('.b5').onclick=()=>buyBuilding(b.id,5);el.querySelector('.u1').onclick=()=>upgBuilding(b.id,1);el.querySelector('.u10').onclick=()=>upgBuilding(b.id,10);buildingCards.appendChild(el)})
}

function buyAndInstallModule(){const t=moduleType.value,id=moduleTarget.value;if(!t||!id)return;const bs=state.buildingState[id],b=state.buildings.find(x=>x.id===id);if(bs.modules.length>=b.slots)return;
  const c=installModuleCost(t);if(state.money>=c.money&&state.materials>=c.materials){state.money-=c.money;state.materials-=c.materials;bs.modules.push(t);state.modulesOwned[t]=(state.modulesOwned[t]||0)+1;updateUI()}}

function saveGame(){localStorage.setItem('bunker2save',JSON.stringify(state))}
function loadGame(){const s=localStorage.getItem('bunker2save');if(!s)return;const obj=JSON.parse(s);Object.assign(state,obj);updateUI()}
function resetGame(){location.reload()}

let last=performance.now();function loop(t){const dt=Math.min(0.05,(t-last)/1000);last=t;tick(dt);draw();if((t|0)%500===0)updateUI();requestAnimationFrame(loop)}
init();
</script>
</body>
</html>
